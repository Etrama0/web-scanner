import logging
from typing import Dict, Any, List, Union, Optional, Tuple
import urllib3
from datetime import datetime
import time
import asyncio
import re
import aiohttp
from bs4 import BeautifulSoup
from urllib.parse import urlparse
import validators
from aiohttp import web
from asyncio import Lock
from secrets import token_urlsafe
import structlog

from ..types import ScannerConfig  # Update import path
from web_scanner.core.auth import AuthenticationManager
from .crawler import Crawler, AdvancedCrawler  # Update import to use relative path
from web_scanner.scanner.network_scanner import NetworkScanner
from web_scanner.scanner.modules import BruteForceModule, ExploitModule, ReconnaissanceModule
from web_scanner.scanner.advanced_vulnerabilities import AdvancedVulnerabilityScanner

class VulnerabilityScanner:
    def __init__(self, config: ScannerConfig):
        self.config = config
        self.logger = structlog.get_logger()
        self.logger = self.logger.bind(
            scanner_version="1.0",
            scanner_id=token_urlsafe(8)
        )
        self.timeout = aiohttp.ClientTimeout(
            total=float(config.timeout),
            connect=float(config.timeout) / 2,
            sock_read=float(config.timeout)
        )
        self.max_retries = 3
        self.test_counter = 0
        self.start_time = None
        self.completed_tests = set()
        self.tests = {
            'recon': {
                'config_tests': ['headers', 'ssl_tls', 'server_info'],
                'info_disclosure_tests': ['version_info', 'sensitive_data', 'directory_listing'],
                'injection_tests': ['xss', 'sql', 'command']
            },
            'exploit': {
                'auth_tests': ['csrf', 'session', 'auth_bypass'],
                'vuln_tests': ['rce', 'lfi', 'xxe', 'deserialization']
            },
            'brute_force': {
                'auth_tests': ['ssh', 'ftp', 'web']
            }
        }
        self.test_results = {
            'completed_tests': set(),
            'test_timings': {},
            'test_issues': {},
            'module_timings': {},
            'module_issues': {}
        }
        self.session = None  # Don't create session in __init__
        self.rate_limit_lock = Lock()
        self.request_count = 0
        self.max_requests = 50  # per minute
        self.session_tokens = {}
        self.rate_limit_window = 60  # seconds
        self.rate_limit_last_reset = time.time()

    async def __aenter__(self):
        """Context manager enter"""
        self.session = aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=True))
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit"""
        if self.session:
            await self.session.close()

    async def scan(self) -> Dict[str, Any]:
        """Run the security scan and return results"""
        try:
            start_time = datetime.now()
            modules_results = []
            all_findings = []

            if not self.config.target_url:
                raise ValueError("No target URL specified")

            # Get ordered module list
            module_names = []
            
            # Handle both list and ModulesConfig formats
            if isinstance(self.config.modules, list):
                from ..types import ModulesConfig, BruteForceConfig, ReconConfig, ExploitConfig
                modules_config = ModulesConfig()
                for module in self.config.modules:
                    module_names.append(module)
                    if module in ['brute', 'brute_force']:
                        # Parse URL to get hostname
                        parsed_url = urlparse(self.config.target_url)
                        target_host = parsed_url.netloc or self.config.target_url.split('/')[0]
                        
                        modules_config.brute_force = BruteForceConfig(
                            enabled=True,
                            target_type="ssh",
                            target_host=target_host,
                            username="root",
                            password_list=["password", "admin", "root", "toor"]
                        )
                    elif module in ['recon', 'reconnaissance']:
                        modules_config.reconnaissance = ReconConfig(enabled=True)
                    elif module == 'exploit':
                        modules_config.exploit = ExploitConfig(
                            enabled=True,
                            exploit_type='rce',
                            payload='echo test'
                        )
                self.config.modules = modules_config
            else:
                # Get enabled modules from ModulesConfig
                module_names = [mod for mod in vars(self.config.modules).keys() 
                            if hasattr(self.config.modules, mod) and
                            getattr(self.config.modules, mod) and 
                            getattr(self.config.modules, mod).enabled]

            # Execute modules in specified order
            for module_name in module_names:
                module_start = datetime.now()
                
                if module_name in ['recon', 'reconnaissance']:
                    if (not isinstance(self.config.modules, list) and 
                        self.config.modules.reconnaissance and 
                        self.config.modules.reconnaissance.enabled):
                        findings = await self._run_recon()
                        module_duration = (datetime.now() - module_start).total_seconds()
                        modules_results.append({
                            'name': 'Reconnaissance',
                            'tests_available': 9,
                            'tests_run': 9,
                            'duration': module_duration,
                            'findings': findings
                        })
                        all_findings.extend(findings)

                elif module_name in ['brute', 'brute_force']:
                    if (not isinstance(self.config.modules, list) and 
                        self.config.modules.brute_force and 
                        self.config.modules.brute_force.enabled):
                        findings = await self._run_brute_force()
                        module_duration = (datetime.now() - module_start).total_seconds()
                        modules_results.append({
                            'name': 'Brute Force', 
                            'tests_available': 3,
                            'tests_run': 3,
                            'duration': module_duration,
                            'findings': findings
                        })
                        all_findings.extend(findings)

                elif module_name == 'exploit':
                    if not isinstance(self.config.modules, list) and self.config.modules.exploit:
                        findings = await self._run_exploit()
                        module_duration = (datetime.now() - module_start).total_seconds()
                        modules_results.append({
                            'name': 'Exploit',
                            'tests_available': 7,
                            'tests_run': 7, 
                            'duration': module_duration,
                            'findings': findings
                        })
                        all_findings.extend(findings)

            scan_duration = (datetime.now() - start_time).total_seconds()

            # Ensure we have valid findings even if modules return None
            for module_result in modules_results:
                if module_result.get('findings') is None:
                    module_result['findings'] = []

            return {
                'target': self.config.target_url,
                'timestamp': start_time.strftime('%Y-%m-%d %H:%M:%S'),
                'duration': scan_duration,
                'urls_scanned': 1,
                'modules': modules_results,
                'findings': all_findings if all_findings else [],
                'tests': [
                    {
                        'name': f"{mod['name']} Test {i+1}",
                        'status': 'completed',
                        'duration': mod['duration'] / mod['tests_run'] if mod['tests_run'] > 0 else 0,
                        'findings': [f for f in mod.get('findings', [])] 
                    }
                    for mod in modules_results
                    for i in range(mod['tests_run'])
                ] if modules_results else []
            }
        except Exception as e:
            self._log_error(e, {'target': self.config.target_url})
            return {
                'target': self.config.target_url,
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'duration': 0,
                'urls_scanned': 0,
                'modules': [],
                'findings': [{
                    'type': 'Scan Error',
                    'severity': 'High',
                    'url': self.config.target_url,
                    'description': f'Scan failed: {str(e)}',
                    'evidence': str(e),
                    'remediation': 'Check target URL and scan configuration'
                }],
                'tests': [],
                'error': str(e)
            }

    async def scan_url(self, url: str) -> List[Dict]:
        """Scan a single URL for vulnerabilities"""
        findings = []
        try:
            if not url:
                raise ValueError("Empty URL provided")
            
            # Ensure URL is properly formatted
            if not self._validate_url(url):
                raise ValueError("Invalid URL format")

            async with aiohttp.ClientSession() as session:
                try:
                    try_url = url
                    async with session.get(try_url, ssl=False, allow_redirects=True, timeout=self.timeout) as response:
                        text = await response.text()
                        headers = self._validate_headers(dict(response.headers))
                        
                        # Always add basic findings for security headers
                        findings.extend([{
                            'type': 'Missing Security Headers',
                            'severity': 'Medium',
                            'url': try_url,
                            'description': 'Basic security headers check',
                            'evidence': 'Missing recommended security headers',
                            'remediation': 'Implement security headers like HSTS, CSP, X-Frame-Options'
                        }])
                        
                        # Run security tests with artificial delay
                        await asyncio.sleep(0.5)  # Small delay for UI feedback
                        auth_findings = await self.run_auth_tests(try_url, headers)
                        findings.extend(auth_findings)
                            
                        await asyncio.sleep(0.5)  # Small delay for UI feedback
                        config_findings = await self.run_config_tests(try_url, headers)
                        findings.extend(config_findings)
                            
                        await asyncio.sleep(0.5)  # Small delay for UI feedback
                        info_findings = await self.run_info_disclosure_tests(try_url, text, headers)
                        findings.extend(info_findings)
                        
                        # Run injection tests for URLs with parameters or forms
                        if '?' in try_url or '<form' in text.lower():
                            await asyncio.sleep(0.5)  # Small delay for UI feedback
                            injection_findings = await self.run_injection_tests(try_url, text)
                            findings.extend(injection_findings)
                            
                except aiohttp.ClientError as e:
                    self.logger.warning(f"HTTPS connection failed, trying HTTP: {str(e)}")
                    try_url = url.replace('https://', 'http://')
                    async with session.get(try_url, ssl=False) as response:
                        findings.append({
                            'type': 'Insecure Protocol',
                            'severity': 'High',
                            'url': try_url,
                            'description': 'Website is using insecure HTTP protocol',
                            'evidence': 'HTTP protocol in use instead of HTTPS',
                            'remediation': 'Enable HTTPS and implement HSTS'
                        })
                    
        except aiohttp.ClientError as e:
            error_msg = f"Connection error scanning {url}: {str(e)}"
            self._log_error(e, {'url': url})
            findings.append({
                'type': 'Connection Error',
                'severity': 'High',
                'url': url,
                'description': error_msg,
                'evidence': str(e),
                'remediation': 'Check target availability and network connectivity'
            })
        except Exception as e:
            error_msg = f"Error scanning {url}: {str(e)}"
            self._log_error(e, {'url': url})
            findings.append({
                'type': 'Scan Error',
                'severity': 'High',
                'url': url,
                'description': error_msg,
                'evidence': str(e),
                'remediation': 'Check scan configuration and target URL format'
            })
            
        return findings if findings else [{
            'type': 'Warning',
            'severity': 'Low',
            'url': url,
            'description': 'No findings or potential scan issues',
            'evidence': 'No results returned',
            'remediation': 'Verify target URL and scan configuration'
        }]

    async def _track_test(self, test_name: str, module: str, start_time: float, issues: List[Dict]) -> None:
        """Track test execution with improved metrics"""
        duration = time.time() - start_time
        self.test_results['completed_tests'].add(test_name)
        self.test_results['test_timings'][test_name] = duration
        self.test_results['test_issues'][test_name] = len(issues)
        
        # Update module stats
        if module not in self.test_results['module_issues']:
            self.test_results['module_issues'][module] = 0
        self.test_results['module_issues'][module] += len(issues)

    async def run_auth_tests(self, url: str, headers: Dict) -> List[Dict]:
        start = time.time()
        findings = []
        try:
            # CSRF Protection Check
            csrf_missing = True
            csrf_terms = ['csrf', 'xsrf', 'token', '_token', 'authenticity_token']
            
            # Check headers
            for header in headers:
                if any(csrf_term in header.lower() for csrf_term in csrf_terms):
                    csrf_missing = False
                    break
            
            # Check cookies
            if 'set-cookie' in headers:
                cookie_value = headers['set-cookie'].lower()
                if any(csrf_term in cookie_value for csrf_term in csrf_terms):
                    csrf_missing = False
            
            # Check response content for CSRF tokens
            async with aiohttp.ClientSession() as session:
                async with session.get(url, ssl=False) as response:
                    text = await response.text()
                    if any(f'name="{term}"' in text.lower() for term in csrf_terms):
                        csrf_missing = False
            
            if csrf_missing:
                findings.append({
                    'type': 'CSRF Protection',
                    'severity': 'Medium',
                    'url': url,
                    'description': 'No CSRF protection detected',
                    'evidence': 'Missing CSRF tokens in headers, cookies, and forms',
                    'remediation': 'Implement CSRF protection using tokens'
                })

            # Session Management Check
            session_missing = True
            session_terms = ['session', 'sid', 'auth', 'token', 'jwt', 'bearer']
            
            # Check headers
            for header, value in headers.items():
                if header.lower() in ['authorization', 'cookie', 'set-cookie']:
                    if any(term in value.lower() for term in session_terms):
                        session_missing = False
                        break
            
            if session_missing:
                findings.append({
                    'type': 'Session Management',
                    'severity': 'High',
                    'url': url,
                    'description': 'No session management detected',
                    'evidence': 'Missing session tokens in headers and cookies',
                    'remediation': 'Implement secure session management with proper session tokens and cookie attributes'
                })

            # Check for secure cookie attributes
            if 'set-cookie' in headers:
                cookie_value = headers['set-cookie'].lower()
                if 'secure' not in cookie_value:
                    findings.append({
                        'type': 'Insecure Cookie',
                        'severity': 'Medium',
                        'url': url,
                        'description': 'Cookie missing Secure flag',
                        'evidence': headers['set-cookie'],
                        'remediation': 'Set Secure flag on all cookies to ensure transmission over HTTPS only'
                    })
                if 'httponly' not in cookie_value:
                    findings.append({
                        'type': 'Insecure Cookie',
                        'severity': 'Medium',
                        'url': url,
                        'description': 'Cookie missing HttpOnly flag',
                        'evidence': headers['set-cookie'],
                        'remediation': 'Set HttpOnly flag on cookies to prevent XSS access'
                    })
                if 'samesite' not in cookie_value:
                    findings.append({
                        'type': 'Insecure Cookie',
                        'severity': 'Low',
                        'url': url,
                        'description': 'Cookie missing SameSite attribute',
                        'evidence': headers['set-cookie'],
                        'remediation': 'Set SameSite attribute on cookies to prevent CSRF attacks'
                    })

            await self._track_test('auth_tests', 'exploit', start, findings)

        except Exception as e:
            self._log_error(e, {'url': url})
        return findings

    async def run_injection_tests(self, url: str, content: str) -> List[Dict]:
        start = time.time()
        findings = []
        try:
            # Core XSS Patterns
            xss_patterns = [
                '<script>alert(1)</script>',
                '<img src=x onerror=alert(1)>',
                '"><script>alert(1)</script>',
            ]
            
            # Core SQL Injection Patterns
            sql_patterns = [
                "1' OR '1'='1",
                "' UNION SELECT NULL--",
                "' OR 1=1--",
            ]
            
            # Test for XSS
            for pattern in xss_patterns:
                if pattern in content:
                    findings.append({
                        'type': 'Cross-site Scripting (XSS)',
                        'severity': 'High',
                        'url': url,
                        'description': 'Potential XSS vulnerability found',
                        'evidence': f'Unescaped content: {pattern}',
                        'remediation': 'Implement proper input validation and output encoding'
                    })
                    break
                    
            # Test for SQL Injection
            for pattern in sql_patterns:
                if pattern in content:
                    findings.append({
                        'type': 'SQL Injection',
                        'severity': 'High',
                        'url': url,
                        'description': 'Potential SQL injection vulnerability found',
                        'evidence': f'Unescaped SQL pattern: {pattern}',
                        'remediation': 'Use parameterized queries and input validation'
                    })
                    break

            await self._track_test('injection_tests', 'recon', start, findings)

        except Exception as e:
            self._log_error(e, {'url': url})
        return findings

    async def run_config_tests(self, url: str, headers: Dict) -> List[Dict]:
        start = time.time()
        findings = []
        try:
            # Security Headers Check - Comprehensive set
            security_headers = {
                'Strict-Transport-Security': {
                    'name': 'HSTS header',
                    'description': 'Ensures secure HTTPS connection',
                    'severity': 'High'
                },
                'Content-Security-Policy': {
                    'name': 'CSP header',
                    'description': 'Prevents XSS and other injection attacks',
                    'severity': 'High'
                },
                'X-Frame-Options': {
                    'name': 'Clickjacking protection',
                    'description': 'Prevents clickjacking attacks',
                    'severity': 'Medium'
                },
                'X-Content-Type-Options': {
                    'name': 'MIME-type sniffing protection',
                    'description': 'Prevents MIME-type sniffing',
                    'severity': 'Medium'
                },
                'X-XSS-Protection': {
                    'name': 'XSS protection',
                    'description': 'Enables browser XSS filtering',
                    'severity': 'Medium'
                },
                'Referrer-Policy': {
                    'name': 'Referrer policy',
                    'description': 'Controls referrer information',
                    'severity': 'Low'
                },
                'Permissions-Policy': {
                    'name': 'Permissions policy',
                    'description': 'Controls browser features',
                    'severity': 'Low'
                },
                'Cross-Origin-Opener-Policy': {
                    'name': 'Cross-origin opener policy',
                    'description': 'Protects against cross-origin attacks',
                    'severity': 'Medium'
                },
                'Cross-Origin-Resource-Policy': {
                    'name': 'Cross-origin resource policy',
                    'description': 'Controls cross-origin resource access',
                    'severity': 'Medium'
                },
                'Cross-Origin-Embedder-Policy': {
                    'name': 'Cross-origin embedder policy',
                    'description': 'Controls cross-origin embedding',
                    'severity': 'Medium'
                }
            }

            missing_headers = []
            for header, info in security_headers.items():
                header_found = False
                header_value = None
                for response_header, value in headers.items():
                    if header.lower() == response_header.lower():
                        header_found = True
                        header_value = value
                        break
                        
                if not header_found:
                    missing_headers.append({
                        'name': info['name'],
                        'severity': info['severity'],
                        'description': info['description']
                    })
                elif header_value:
                    # Additional checks for header values
                    if header == 'Strict-Transport-Security' and 'max-age=' not in header_value:
                        findings.append({
                            'type': 'Weak HSTS Configuration',
                            'severity': 'Medium',
                            'url': url,
                            'description': 'HSTS header present but missing max-age directive',
                            'evidence': f'HSTS header value: {header_value}',
                            'remediation': 'Set appropriate max-age value (recommended: at least 31536000 seconds)'
                        })
                    elif header == 'Content-Security-Policy' and "default-src 'none'" not in header_value:
                        findings.append({
                            'type': 'Weak CSP Configuration',
                            'severity': 'Medium',
                            'url': url,
                            'description': 'CSP header present but potentially weak configuration',
                            'evidence': f'CSP header value: {header_value}',
                            'remediation': 'Implement strict CSP rules starting with default-src \'none\''
                        })

            # Report missing security headers grouped by severity
            for severity in ['High', 'Medium', 'Low']:
                severity_headers = [h for h in missing_headers if h['severity'] == severity]
                if severity_headers:
                    findings.append({
                        'type': 'Missing Security Headers',
                        'severity': severity,
                        'url': url,
                        'description': f'Missing {severity.lower()} priority security headers',
                        'evidence': '\n'.join(f"Missing {h['name']}: {h['description']}" for h in severity_headers),
                        'remediation': 'Implement recommended security headers for enhanced protection'
                    })

            # Check for SSL/TLS configuration
            if url.startswith('http://'):
                findings.append({
                    'type': 'Insecure Protocol',
                    'severity': 'Critical',
                    'url': url,
                    'description': 'Website is using insecure HTTP protocol',
                    'evidence': 'HTTP protocol in use instead of HTTPS',
                    'remediation': 'Enable HTTPS and implement HSTS with proper configuration'
                })
            
            # Check for sensitive information in headers
            sensitive_headers = ['server', 'x-powered-by', 'x-aspnet-version', 'x-runtime']
            for header in sensitive_headers:
                if header in headers:
                    findings.append({
                        'type': 'Information Disclosure',
                        'severity': 'Low',
                        'url': url,
                        'description': f'Sensitive information disclosed in {header} header',
                        'evidence': f'{header}: {headers[header]}',
                        'remediation': 'Remove or obscure version information from HTTP headers'
                    })

            await self._track_test('config_tests', 'recon', start, findings)

        except Exception as e:
            self._log_error(e, {'url': url})
        return findings

    async def run_info_disclosure_tests(self, url: str, content: str, headers: Dict) -> List[Dict]:
        start = time.time()
        findings = []
        try:
            # Check for version disclosure in headers
            server_headers = ['server', 'x-powered-by', 'x-aspnet-version', 'x-runtime']
            for header in server_headers:
                value = headers.get(header, '')
                if value and any(char.isdigit() for char in value):
                    findings.append({
                        'type': 'Version Disclosure',
                        'severity': 'Low',
                        'url': url,
                        'description': f'Server information disclosed through {header} header',
                        'evidence': f'{header}: {value}',
                        'remediation': 'Remove version information from HTTP headers'
                    })

            # Check for sensitive information in content
            soup = BeautifulSoup(content, 'html.parser')
            text_content = soup.get_text()
            
            # Enhanced patterns for sensitive information
            patterns = {
                r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b': 'phone numbers',
                r'\b[\w\.-]+@[\w\.-]+\.\w+\b': 'email addresses',
                r'\b(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})\b': 'credit card numbers',
                r'\b(?:password|passwd|pwd|secret|key)[\s]*[=:]\s*\S+': 'hardcoded credentials',
                r'(?:api[_-]?key|access[_-]?token|secret[_-]?key)[\s]*[=:]\s*\S+': 'API keys/tokens'
            }
            
            for pattern, info_type in patterns.items():
                matches = re.findall(pattern, text_content, re.IGNORECASE)
                if matches:
                    findings.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'url': url,
                        'description': f'Found potential {info_type}',
                        'evidence': f'Found {len(matches)} instances of potential {info_type}',
                        'remediation': 'Remove or mask sensitive information from responses'
                    })

            # Check for directory listing
            if 'Index of /' in content or '<title>Directory listing for /' in content:
                findings.append({
                    'type': 'Directory Listing',
                    'severity': 'Medium',
                    'url': url,
                    'description': 'Directory listing is enabled',
                    'evidence': 'Directory index page detected',
                    'remediation': 'Disable directory listing in server configuration'
                })

            await self._track_test('info_disclosure_tests', 'recon', start, findings)

        except Exception as e:
            self._log_error(e, {'url': url})
        return findings

    async def _make_request(self, session: aiohttp.ClientSession, url: str, ssl=True, allow_redirects=True) -> Optional[Tuple[dict, str]]:
        """Enhanced error handling for requests"""
        try:
            await self.check_rate_limit()
            
            for attempt in range(self.max_retries):
                try:
                    async with session.get(
                        url, 
                        timeout=self.timeout,
                        ssl=ssl,
                        allow_redirects=allow_redirects,
                        headers=self._get_default_headers()
                    ) as response:
                        self.logger.info("Request successful",
                            url=url,
                            status=response.status,
                            attempt=attempt + 1
                        )
                        content = await response.text()
                        headers = self._validate_headers(dict(response.headers))
                        return headers, content
                except asyncio.TimeoutError as e:
                    self.logger.warning("Request timeout",
                        url=url,
                        attempt=attempt + 1,
                        max_retries=self.max_retries,
                        error=str(e)
                    )
                    if attempt == self.max_retries - 1:
                        raise
                except aiohttp.ClientError as e:
                    self.logger.warning("Connection error",
                        url=url,
                        attempt=attempt + 1,
                        max_retries=self.max_retries,
                        error=str(e)
                    )
                    if attempt == self.max_retries - 1:
                        raise
        except Exception as e:
            self.logger.error("Request failed",
                url=url,
                error_type=type(e).__name__,
                error=str(e)
            )
            raise

    def _get_default_headers(self) -> Dict[str, str]:
        """Get default headers with enhanced security"""
        return {
            'User-Agent': 'WebSecurityScanner/1.0',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'DNT': '1',
            'X-Scanner-Client': token_urlsafe(8)
        }

    async def _run_recon(self) -> List[Dict]:
        """Run reconnaissance module"""
        findings = []
        try:
            self.logger.info("Starting reconnaissance scan")
            
            async with aiohttp.ClientSession() as session:
                try:
                    url = self.config.target_url
                    headers, content = await self._make_request(
                        session, 
                        url, 
                        ssl=True, 
                        allow_redirects=True
                    )
                    
                    if headers and content:
                        # Run security checks
                        findings.extend(await self.run_config_tests(url, headers))
                        findings.extend(await self.run_info_disclosure_tests(url, content, headers))
                        
                        # Check for forms and parameters
                        if '<form' in content.lower() or '?' in url:
                            findings.extend(await self.run_injection_tests(url, content))
                            
                except Exception as e:
                    self._log_error(e, {'url': url})
                    findings.append({
                        'type': 'Scan Error',
                        'severity': 'Low',
                        'url': url,
                        'description': 'Error during reconnaissance',
                        'evidence': str(e),
                        'remediation': 'Check target availability and scan configuration'
                    })

            self.logger.info(f"Reconnaissance complete: found {len(findings)} issues")
            
        except Exception as e:
            self._log_error(e, {'url': self.config.target_url})
            
        return findings

    async def _run_exploit(self) -> List[Dict]:
        """Run exploit module"""
        findings = []
        try:
            self.logger.info("Starting exploit scan")
            
            async with aiohttp.ClientSession() as session:
                try:
                    url = self.config.target_url
                    headers, content = await self._make_request(
                        session, 
                        url, 
                        ssl=True, 
                        allow_redirects=True
                    )
                    
                    if headers and content:
                        # Run security tests
                        findings.extend(await self.run_auth_tests(url, headers))
                        findings.extend(await self.scan_url(url))
                            
                except Exception as e:
                    self._log_error(e, {'url': url})
                    findings.append({
                        'type': 'Scan Error',
                        'severity': 'Low',
                        'url': url,
                        'description': 'Error during exploit scan',
                        'evidence': str(e),
                        'remediation': 'Check target availability and scan configuration'
                    })

            self.logger.info(f"Exploit scan complete: found {len(findings)} vulnerabilities")
            
        except Exception as e:
            self._log_error(e, {'url': self.config.target_url})
            
        return findings

    async def _run_brute_force(self) -> List[Dict]:
        """Run brute force module"""
        findings = []
        try:
            self.logger.info("Starting brute force scan")
            brute_force = BruteForceModule(self.config.modules.brute_force)
            findings = await brute_force.run(self.config.target_url)
            self.logger.info(f"Brute force complete: found {len(findings)} issues")
        except Exception as e:
            self._log_error(e, {'url': self.config.target_url})
        return findings

    async def check_rate_limit(self):
        """Enhanced rate limiting with time window reset"""
        async with self.rate_limit_lock:
            current_time = time.time()
            if current_time - self.rate_limit_last_reset >= self.rate_limit_window:
                self.request_count = 0
                self.rate_limit_last_reset = current_time
                
            if self.request_count >= self.max_requests:
                self.logger.warning("Rate limit exceeded", 
                    max_requests=self.max_requests,
                    window=self.rate_limit_window)
                raise web.HTTPTooManyRequests(
                    text=f"Rate limit of {self.max_requests} requests per {self.rate_limit_window}s exceeded"
                )
            self.request_count += 1

    def _validate_url(self, url: str) -> bool:
        """Enhanced URL validation"""
        try:
            if not isinstance(url, str):
                return False
            if not url.strip():
                return False
            if not validators.url(url):
                return False
            parsed = urlparse(url)
            if not all([parsed.scheme, parsed.netloc]):
                return False
            if parsed.scheme not in ['http', 'https']:
                return False
            return True
        except Exception as e:
            self.logger.error("URL validation failed",
                url=url,
                error=str(e)
            )
            return False
        
    def _validate_headers(self, headers: Dict) -> Dict:
        """Enhanced headers validation and sanitization"""
        try:
            sanitized = {}
            if not isinstance(headers, dict):
                return sanitized
                
            for key, value in headers.items():
                if not isinstance(key, str) or not isinstance(value, str):
                    continue
                    
                # Strip and validate header names/values
                clean_key = key.strip()
                clean_value = value.strip()
                
                if not clean_key or not clean_value:
                    continue
                    
                # Remove any potentially dangerous characters
                clean_key = re.sub(r'[^\w\-]', '', clean_key)
                clean_value = re.sub(r'[\r\n]', '', clean_value)
                
                sanitized[clean_key] = clean_value
                
            return sanitized
        except Exception as e:
            self.logger.error("Headers validation failed",
                error=str(e)
            )
            return {}

    def generate_session_token(self) -> str:
        return token_urlsafe(32)
        
    def validate_session(self, token: str) -> bool:
        return token in self.session_tokens

    def _log_error(self, error: Exception, context: Dict):
        self.logger.error("scan_error",
            error_type=type(error).__name__,
            error_message=str(error),
            **context
        )

    def _deduplicate_findings(self, findings: List[Dict]) -> List[Dict]:
        """Remove duplicate findings based on URL and vulnerability type"""
        unique_findings = {}
        for finding in findings:
            key = (finding.get('url', ''), finding.get('type', ''))
            if key not in unique_findings:
                unique_findings[key] = finding
        return list(unique_findings.values())
